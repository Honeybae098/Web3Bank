<parameter name="content">import React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';
import { ethers } from 'ethers';
import { AUTH_ERRORS, authUtils } from '../utils/authUtils';
import { SmartBankConfig } from '../config/SmartBankConfig';
import { getStoredSession, updateSession, clearStoredSession } from '../services/sessionService';

const Web3Context = createContext();

export const useWeb3 = () => {
  const context = useContext(Web3Context);
  if (!context) {
    throw new Error('useWeb3 must be used within a Web3Provider');
  }
  return context;
};

export const Web3Provider = ({ children }) => {
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [network, setNetwork] = useState(null);
  const [address, setAddress] = useState('');
  const [isConnected, setIsConnected] = useState(false);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [contract, setContract] = useState(null);
  const [balance, setBalance] = useState('0');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isContractInitialized, setIsContractInitialized] = useState(false);
  const [canTransact, setCanTransact] = useState(false);
  const [transactionHistory, setTransactionHistory] = useState([]);

  const { extendSession, hasRole } = authUtils();

  // Initialize Web3 provider
  const initializeProvider = useCallback(() => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        const web3Provider = new ethers.BrowserProvider(window.ethereum);
        setProvider(web3Provider);
        return web3Provider;
      } catch (err) {
        console.error('Failed to initialize provider:', err);
        setError('Failed to initialize Web3 provider');
        return null;
      }
    } else {
      setError('MetaMask is not installed');
      return null;
    }
  }, []);

  // Setup event listeners
  const setupEventListeners = useCallback(() => {
    if (!window.ethereum) return;

    window.ethereum.on('accountsChanged', (accounts) => {
      if (accounts.length > 0) {
        setAddress(accounts[0]);
        setIsConnected(true);
      } else {
        setIsConnected(false);
        setAddress('');
      }
    });

    window.ethereum.on('chainChanged', (chainId) => {
      window.location.reload();
    });

    window.ethereum.on('disconnect', () => {
      disconnectWallet();
    });
  }, []);

  // Cleanup event listeners
  const cleanupEventListeners = useCallback(() => {
    if (!window.ethereum) return;

    window.ethereum.removeAllListeners('accountsChanged');
    window.ethereum.removeAllListeners('chainChanged');
    window.ethereum.removeAllListeners('disconnect');
  }, []);

  // Connect wallet
  const connectWallet = useCallback(async () => {
    try {
      setIsLoading(true);
      const web3Provider = provider || initializeProvider();
      if (!web3Provider) return;

      // Request account access
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      
      const network = await web3Provider.getNetwork();
      setNetwork(network);
      
      const signer = await web3Provider.getSigner();
      setSigner(signer);
      
      const address = await signer.getAddress();
      setAddress(address);
      
      setIsConnected(true);
      
      // Check session
      const session = getStoredSession();
      if (session && session.isAuthenticated && session.address === address) {
        setIsAuthenticated(true);
      }
      
      // Get balance
      const balance = await web3Provider.getBalance(address);
      setBalance(ethers.formatEther(balance));
      
      setError(null);
    } catch (err) {
      console.error('Failed to connect wallet:', err);
      setError('Failed to connect wallet');
    } finally {
      setIsLoading(false);
    }
  }, [provider, initializeProvider]);

  // Disconnect wallet
  const disconnectWallet = useCallback(() => {
    setProvider(null);
    setSigner(null);
    setNetwork(null);
    setAddress('');
    setIsConnected(false);
    setIsAuthenticated(false);
    setContract(null);
    setBalance('0');
    setIsContractInitialized(false);
    setCanTransact(false);
    clearStoredSession();
  }, []);

  // Verify wallet connection
  const verifyWalletConnection = useCallback(async () => {
    try {
      if (!window.ethereum) return false;
      
      const accounts = await window.ethereum.request({ method: 'eth_accounts' });
      if (accounts.length === 0) return false;
      
      const web3Provider = new ethers.BrowserProvider(window.ethereum);
      const network = await web3Provider.getNetwork();
      const signer = await web3Provider.getSigner();
      const address = await signer.getAddress();
      
      setProvider(web3Provider);
      setSigner(signer);
      setNetwork(network);
      setAddress(address);
      setIsConnected(true);
      
      // Get balance
      const balance = await web3Provider.getBalance(address);
      setBalance(ethers.formatEther(balance));
      
      return true;
    } catch (err) {
      console.error('Failed to verify wallet connection:', err);
      return false;
    }
  }, []);

  // Update balance
  const updateBalance = useCallback(async () => {
    if (!provider || !address) return;
    
    try {
      const balance = await provider.getBalance(address);
      setBalance(ethers.formatEther(balance));
    } catch (err) {
      console.error('Failed to update balance:', err);
    }
  }, [provider, address]);

  // Initialize contract
  const initializeContract = useCallback(async () => {
    if (!signer || !address) return;
    
    try {
      setIsLoading(true);
      
      // Check if we have an authenticated session
      const session = getStoredSession();
      if (!session || !session.isAuthenticated || session.address !== address) {
        setIsAuthenticated(false);
        setIsContractInitialized(false);
        setCanTransact(false);
        return;
      }
      
      // Initialize contract
      const contractInstance = new ethers.Contract(
        SmartBankConfig.contractAddress,
        SmartBankConfig.contractABI,
        signer
      );
      
      setContract(contractInstance);
      setIsContractInitialized(true);
      setCanTransact(true);
      setIsAuthenticated(true);
      
      // Load transaction history
      const history = await contractInstance.getHistory(address);
      setTransactionHistory(history.map(tx => ({
        type: tx.txType,
        amount: ethers.formatEther(tx.amount),
        timestamp: new Date(tx.timestamp * 1000).toLocaleString()
      })));
      
      setError(null);
    } catch (err) {
      console.error('Failed to initialize contract:', err);
      setError('Failed to initialize SmartBank contract');
      setIsContractInitialized(false);
      setCanTransact(false);
    } finally {
      setIsLoading(false);
    }
  }, [signer, address]);

  // Auto-initialize contract when wallet is connected and authenticated
  useEffect(() => {
    if (provider && signer && network && isAuthenticated && address) {
      console.log('Initializing SmartBank contract...');
      initializeContract();
    }
  }, [provider, signer, network, isAuthenticated, address, initializeContract]);

  // Set up event listeners on mount
  useEffect(() => {
    setupEventListeners();
    
    // Check if wallet is already connected
    verifyWalletConnection();
    
    return () => {
      cleanupEventListeners();
    };
  }, [setupEventListeners, cleanupEventListeners, verifyWalletConnection]);

  // Auto-connect on mount if previously connected
  useEffect(() => {
    const handleAccountsChanged = (accounts) => {
      if (accounts.length > 0) {
        connectWallet();
      } else {
        disconnectWallet();
      }
    };
    
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', handleAccountsChanged);
      
      // Check if already connected
      window.ethereum.request({ method: 'eth_accounts' })
        .then(accounts => {
          if (accounts.length > 0) {
            connectWallet();
          }
        })
        .catch(err => console.error('Failed to check accounts:', err));
    }
    
    return () => {
      if (window.ethereum) {
        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
      }
    };
  }, [connectWallet, disconnectWallet]);

  // Context value
  const value = useMemo(() => ({
    provider,
    signer,
    network,
    address,
    isConnected,
    isAuthenticated,
    contract,
    balance,
    isLoading,
    error,
    isContractInitialized,
    canTransact,
    transactionHistory,
    connectWallet,
    disconnectWallet,
    updateBalance,
    initializeContract
  }), [
    provider,
    signer,
    network,
    address,
    isConnected,
    isAuthenticated,
    contract,
    balance,
    isLoading,
    error,
    isContractInitialized,
    canTransact,
    transactionHistory,
    connectWallet,
    disconnectWallet,
    updateBalance,
    initializeContract
  ]);

  return (
    <Web3Context.Provider value={value}>
      {children}
    </Web3Context.Provider>
  );
};</parameter>
